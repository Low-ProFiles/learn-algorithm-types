### 1. 그리디 알고리즘 ( Greedy )

#### 개요

- 현재 상황에서 가장 좋은 것을 고르는 방법
- 일반적으로 문제를 풀기 위해 최소한의 아이디어를 떠올릴 수 있어야 한다.
- 가장 좋아 보이는 것을 반복 선택했을 때, 최적의 해를 구할 수 있다는 보장이 없기 때문에 정당성 분석이 중요하다.
<details>
<summary>문제</summary>
<div markdown="1">

- Change.py

> 손님에게 거슬러 주어야 할 돈이 N원일 때, 거슬러 주어야 할 동전의 최고 개수를 구하여라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이며 동전의 종류는 500원, 100원, 50원, 10원 4가지이다.

- TilTheOne.py

> 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다. 이때, N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하여라.
>
> 1.  N에서 1을 뺀다.
> 2.  N을 K로 나눈다.

- Calculate.py

> 각 자리가 0부터 9로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하여라. 단, 모든 연산은 왼쪽에서부터 순서대로 이루어진다.

- Adventure.py

> 한 마을에 모험가가 N명 있다. 모험가 길드에서 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에 제대로 대처할 능력이 떨어진다. 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있다. N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹의 최댓값을 구하여라.

</div>
</details>
</br>

### 2. 구현 알고리즘 ( Implementation )

#### 개요

- 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제
  - 알고리즘은 간단하나 코드가 지나치게 길어지는 문제
  - 실수 연산을 다루고, 특정 소수점 자리까지 출력하는 문제
  - 문자열을 특정 기준에 따라서 끊어 처리하는 문제
  - 적절한 라이브러리를 찾아서 사용하는 문제
- 시뮬레이션 및 완전 탐색 문제에서 2차원 공간에서의 방향 벡터가 자주 활용된다.
<details>
<summary>문제</summary>
<div markdown="1">

- UpDown.py

> 여행가 A는 1 _ 1 크기의 정사각형으로 이루어진 N _ N 크기의 공간 위에 서 있다. 가장 왼쪽 위는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. A는 상,하,좌,우로 한 칸씩 이동할 수 있으며 시작 좌표는 항상 (1, 1)이다. N \* N 크기의 공간을 벗어나는 움직은 무시될 때, 상하좌우가 적힌 계획서를 보고 A가 최종적으로 도착할 지점의 좌표를 구하여라

- CountThree.py

> 정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하여라.

- Chess.py

> 8 \* 8 좌표 평면에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 모두 구하여라. 행의 위치는 1부터 8로 표현하며 열의 위치는 a부터 h로 표현한다.

- Rearrangement.py

> 알파벳 대문자와 숫자(0 ~ 9)로만 구성된 문자열이 입력으로 주어집니다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에 그 뒤에 모든 숫자를 더한 값을 이어서 출력하여라.

</div>
</details>
</br>

### 3. 너비 / 깊이 우선 탐색 ( BFS / DFS )
